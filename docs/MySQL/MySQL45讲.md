## 一条SQL的查询是如何执行的

![01](..\MySQL\img\01.png)

MySQL可以分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。



而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。

### 连接器

负责和客户端建立连接，获取权限，维持和管理连接。



连接完成之后，如果没有后续的动作，连接就处于空闲状态，可以在show processlist命令中看到他。



客户端太长没有动静，连接器就会自动将他断开，这个时间是由wait_timeout 控制的，默认是8个小时。

如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。



建立连接的过程通常是比较复杂的，所以一般建议使用长连接，并且使用连接池将连接进行管理。



使用长连接会有个问题，就是内存涨的特别快，这是MySQL在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才会进行释放。



解决方案：

1. 定期断开长连接
2. 但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉
   （OOM），从现象看就是 MySQL 异常重启了。

### 查询缓存



建立连接后面就是查询缓存，但是建议不要使用查询缓存，因为缓存往往弊大于利。

可能出现刚缓存的数据，还没使用就被一个更新全清空了。

### 分析器

分析器所做的事情就是语法分析，识别你是否是一个正确的查询语法

### 优化器

优化器的作用是在查询过程中，通过成本进行计算应该走哪一个索引，或者是全表查询。

优化器阶段完成之后，这个语句的执行方案就确定下来了，然后进入执行阶段。

### 执行器

由于MySQL是插拔式 插件式的架构，所以会有不同的存储引擎，执行器就会根据表的引擎定义去执行不同的存储引擎去执行这条语句的查询。

对表的权限的检查也是在这一步。

## 一条SQL的更新语句是如何执行的



更新语句中redo log和bin log的重要性

### InnoDB的重要内存结构：缓冲池



**InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是缓冲池（Buffer Pool），这里面会缓存很多的数据，以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了。**

### redo log

MySQL中，如果每次更新操作写入磁盘，然后磁盘找到对应记录进行更新，整个的io成本都很高，如果直接写入内存就认定此次更新结束，此时性能会很高，但是如果此时内存里面的数据进行了修改，但是磁盘上数据还没修改，如果MySQL所在服务器宕机，就会导致修改过的数据丢失。

为了解决这个问题采用了WAl技术来提升更新效率。WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。

此时就必须把内存所做的修改写入Redo Log BUffer里去，这个也是内存的缓冲区，用来存放redo 日志的。

redo日志，记录你对数据做了修改。并且是一个物理日志，告知哪一个内存页进行了怎么样的修改。

redo log的大小是固定的，如果配置一组4个文件，每个文件大小是1GB，那么redo log就可以记录4G的日志大小，写到日志尾部就循环回到开头继续写。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。

####  Redo Log 刷盘策略



由于redo log buffer是在内存中，此时如果宕机还是会出现数据丢失，此时就相当于事务未提交成功。

但如果要提交一个事务，就得把redo log buffer 里面的内容写入redo log磁盘中。



此时是通过一定的策略将数据写入磁盘的。这个策略是通过innodb_flush_log_at_trx_commit来配置的，他有几个选项。

- 当值为0的时候，提交事务的时候是不会把buffer里面的值刷入磁盘。
- 当值为1的时候，提交事务的时候就必须把buffer写入磁盘。
- 当值为2的时候，提交事务的时候就把buffer写入os cache中，最终由操作系统决定什么时候刷入磁盘。

所以刷盘策略通常建议选择1，也就是说提交事务的时候，redo 日志必须刷入磁盘的。

### bin log

MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为binlog（归档日志）



提交事务的时候同时还会把数据写入到binlog，对于提交事务的阶段 也就是  **redo 刷入磁盘以及binlog日志写入磁盘两个阶段了。**

#### binlog 刷盘策略

**binlog日志也有不同的刷盘策略，参数是sync_binlog**



- 当值为0的时候（默认），会将binlog日志写入os cache内存缓存，由操作系统决定什么时候刷入磁盘。
- 当值为1的时候，会强制在提交事务的时候，将binlog写入到磁盘文件去



#### **redo log 和binlog的区别**



1. redo log是innodb 存储引擎特有的，binlog 是MySQL的server层实现的，所有引擎都可以使用。
2. redolog 是物理日志，记录在某个数据页上走了什么修改，bin log是逻辑日志，记录的是这个语句的原始逻辑，比如给id=2这一行的c字段加1.
3. redo log是循环写的，空间固定会用完，bin log 是可以追加的。



![02](..\MySQL\img\2.png)





后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

### 两阶段提交

#### 怎样让数据库恢复到半个月内任意一秒的状态？

binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
- 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。



#### 为什么要采用两阶段提交：

如果不采用2阶段提交，会有什么问题

1. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

2. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。



## 事务隔离：为什么你改了我还看不见？

### 隔离性和隔离级别

事务的四大特性（ACID）：

原子性，一致性，隔离性，持久性



sql标准的事务隔离级别包括：读未提交，读已提交，可重复读，串行化

读未提交：一个事务还没提交时，他做的变更就能被其他事务看到

读提交：一个事务已经提交之后，他的变更才会被其他事务看到

可重复读：一个事务执行过程中看到的数据，总是跟这个事务启动时看到的数据是一致的。

串行化：串行执行sql

### 事务隔离的实现

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![3](..\MySQL\img\3.png)

如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。



## 深入浅出索引

#### 常见的索引：

1. 哈希表：是一种以 键值（key-value）存储数据的结构。   哈希表适用于只有等值查询的场景。
2. 有序数组：在等值查询和范围查询中的性能都非常优秀。 但是只适用于静态存储引擎。
3. 二叉搜索树： 每个节点的左儿子小于父节点，父节点又小于又儿子。

#### innodb的索引模型：

innodb的索引模型是 B+树，根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。



#### 索引维护

B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护，如果新插入的数据是在一个页数据的中间，此时数据页满了，就会需要申请一个新的数据页，然后挪动部分数据过去，此时就会产生页分裂。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。



然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。



#### 覆盖索引：

查询的数据已经在索引树上了，因此我们可以直接提供查询结果，不需要回表，此时的查询需要我们称之为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

#### 最左前缀原则

只要满足索引最左匹配原则，就能利用索引来加速索引，这个索引可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

#### 索引下推

MySQL5.6之前，对于联合索引的查询来说，如果对前一个索引值采用最模糊查询，此时对第2个索引字段的判定只能通过回表进行查询判断，而且5.6之后，引入了索引下推优化，可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

## 全局锁和表锁

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。



### 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL 命令了。

### 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。



表锁的语法是 lock tables ... read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。



另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

## 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。



两阶段锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

### 快照在MVCC里是怎么工作的

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 rowtrx_id。

在事务启动的时候，会按照启动的时候事务ID 生成快照。

数组里面事务id最小值记为低水位，最大id+1记为高水位。

![4](../MySQL\img\4.png)

这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
   a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
   b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

更新逻辑

更新语句如果按照一致性读，此时的结果不太对。

所以在更新的时候都是先读后写，而这个读只能是读当前的值，也称为当前读。

### 事务的可重复读的能力是怎么实现的



可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。



### 普通索引和唯一索引应该怎么选

#### 数据的更新过程：

当需要更新一个数据的时候，如果数据在内存页中就直接更新，如果没有在内存页中，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在change buffer中,这样就不需要从磁盘中读取这个数据。



#### change buffer的作用

通过change buffer 提供写性能。如果将更新操作记录在change buffer，减少读磁盘，语句的执行数据会得到明显的提升。



#### 什么情况下可以使用change buffer

对于唯一索引来说，更新操作需要判断这个操作是否违反唯一性约束，所以在有唯一索引的情况下不能使用change buffer了。

所以对于唯一索引和普通索引，如果在业务上能够判断唯一性的前提下，可以使用普通索引来提高性能。

#### 写入使用了 change buffer 机制，之后主机异常重启，是否会丢失 change buffer 和数据。

虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。

### MySQL为什么会选择错索引

#### 优化器的逻辑

对于索引的选择，实际上是优化器的工作。

优化器的目的是找个一个最优的代价去执行语句，实际上也就是扫描更少的行去执行这个语句，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的cpu越少。

当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。



MySQL 在真正的执行语句之前，并不能精确的知道扫描的行数有多少，而是通过统计信息来估算记录数。

这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。

而这个基数是如何计算的呢，MySQL并不会把整张表进行统计，而是采用采样统计的方式，默认选择N个数据页，统计页上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1/M 的时候，会自动触发重新做一次索引统计。

在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent的值来选择：

​	设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。
​	设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。



如果MySQL选错索引，可以进行修正，analyze table t 命令，可以用来重新统计索引信息。



综合可知：MySQL是基于最优成本的方式去选择索引，在选择索引的时候会根据索引的区分度，以及是否回表，是否使用临时表，是否排序等因素进行综合判断的。如果选择错误，可能是没能准确判断出扫描行数，此时可以做修正。也可以采用 force index 强行选择一个索引.



### 怎么给字符串字段加索引

1. 直接创建完整索引，这样可能比较占用空间；
2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；

3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；

4. 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。
