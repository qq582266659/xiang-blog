## 一条SQL的查询是如何执行的

![01](..\MySQL\img\01.png)

MySQL可以分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。



而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。

### 连接器

负责和客户端建立连接，获取权限，维持和管理连接。



连接完成之后，如果没有后续的动作，连接就处于空闲状态，可以在show processlist命令中看到他。



客户端太长没有动静，连接器就会自动将他断开，这个时间是由wait_timeout 控制的，默认是8个小时。

如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。



建立连接的过程通常是比较复杂的，所以一般建议使用长连接，并且使用连接池将连接进行管理。



使用长连接会有个问题，就是内存涨的特别快，这是MySQL在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才会进行释放。



解决方案：

1. 定期断开长连接
2. 但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉
   （OOM），从现象看就是 MySQL 异常重启了。

### 查询缓存



建立连接后面就是查询缓存，但是建议不要使用查询缓存，因为缓存往往弊大于利。

可能出现刚缓存的数据，还没使用就被一个更新全清空了。

### 分析器

分析器所做的事情就是语法分析，识别你是否是一个正确的查询语法

### 优化器

优化器的作用是在查询过程中，通过成本进行计算应该走哪一个索引，或者是全表查询。

优化器阶段完成之后，这个语句的执行方案就确定下来了，然后进入执行阶段。

### 执行器

由于MySQL是插拔式 插件式的架构，所以会有不同的存储引擎，执行器就会根据表的引擎定义去执行不同的存储引擎去执行这条语句的查询。

对表的权限的检查也是在这一步。

## 一条SQL的更新语句是如何执行的



更新语句中redo log和bin log的重要性

### InnoDB的重要内存结构：缓冲池



**InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是缓冲池（Buffer Pool），这里面会缓存很多的数据，以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了。**

### redo log

MySQL中，如果每次更新操作写入磁盘，然后磁盘找到对应记录进行更新，整个的io成本都很高，如果直接写入内存就认定此次更新结束，此时性能会很高，但是如果此时内存里面的数据进行了修改，但是磁盘上数据还没修改，如果MySQL所在服务器宕机，就会导致修改过的数据丢失。

为了解决这个问题采用了WAl技术来提升更新效率。WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。

此时就必须把内存所做的修改写入Redo Log BUffer里去，这个也是内存的缓冲区，用来存放redo 日志的。

redo日志，记录你对数据做了修改。并且是一个物理日志，告知哪一个内存页进行了怎么样的修改。

redo log的大小是固定的，如果配置一组4个文件，每个文件大小是1GB，那么redo log就可以记录4G的日志大小，写到日志尾部就循环回到开头继续写。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。

####  Redo Log 刷盘策略



由于redo log buffer是在内存中，此时如果宕机还是会出现数据丢失，此时就相当于事务未提交成功。

但如果要提交一个事务，就得把redo log buffer 里面的内容写入redo log磁盘中。



此时是通过一定的策略将数据写入磁盘的。这个策略是通过innodb_flush_log_at_trx_commit来配置的，他有几个选项。

- 当值为0的时候，提交事务的时候是不会把buffer里面的值刷入磁盘。
- 当值为1的时候，提交事务的时候就必须把buffer写入磁盘。
- 当值为2的时候，提交事务的时候就把buffer写入os cache中，最终由操作系统决定什么时候刷入磁盘。

所以刷盘策略通常建议选择1，也就是说提交事务的时候，redo 日志必须刷入磁盘的。

### bin log

MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为binlog（归档日志）



提交事务的时候同时还会把数据写入到binlog，对于提交事务的阶段 也就是  **redo 刷入磁盘以及binlog日志写入磁盘两个阶段了。**

#### binlog 刷盘策略

**binlog日志也有不同的刷盘策略，参数是sync_binlog**



- 当值为0的时候（默认），会将binlog日志写入os cache内存缓存，由操作系统决定什么时候刷入磁盘。
- 当值为1的时候，会强制在提交事务的时候，将binlog写入到磁盘文件去



#### **redo log 和binlog的区别**



1. redo log是innodb 存储引擎特有的，binlog 是MySQL的server层实现的，所有引擎都可以使用。
2. redolog 是物理日志，记录在某个数据页上走了什么修改，bin log是逻辑日志，记录的是这个语句的原始逻辑，比如给id=2这一行的c字段加1.
3. redo log是循环写的，空间固定会用完，bin log 是可以追加的。



![02](..\MySQL\img\2.png)





后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

### 两阶段提交

#### 怎样让数据库恢复到半个月内任意一秒的状态？

binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
- 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。



#### 为什么要采用两阶段提交：

如果不采用2阶段提交，会有什么问题

1. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

2. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。